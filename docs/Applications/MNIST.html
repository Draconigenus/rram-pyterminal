<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>MNIST API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MNIST</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import CommandMap as CM
import PyTerminal as PT

import importlib
import random
import time
import numpy as np
import io
import torch
import math

import RRAM, DNN

from tkinter import *
from tkinter import font
from functools import partial

from PIL import Image, ImageTk


def conf_network(network, verbal):
    &#34;&#34;&#34; Configure MNIST network type

    Args:
        network (str): Network type
        verbal (bool): Whether to print the configured network or not.
    &#34;&#34;&#34;

    # Some global variabls
    global folder_dir
    global weights, targets, sim_preds
    global images, image_len
    global mapping
    global layers

    # Folder directory
    if &#39;folder_dir&#39; in globals():
        sys.path.remove(folder_dir)

    if network == &#39;MLP&#39;:
        folder_dir = &#39;D:\Dropbox (GaTech)\GaTech\ICSRL\Projects\9. RRAM\Evaluation Board\MNIST\data_256_fc32_fc10&#39;
    elif network == &#39;MLP2&#39;:
        folder_dir = &#39;D:\Dropbox (GaTech)\GaTech\ICSRL\Projects\9. RRAM\Evaluation Board\MNIST\data_484_fc64_fc10&#39;
    elif network == &#39;CONV&#39;:
        folder_dir = &#39;D:\Dropbox (GaTech)\GaTech\ICSRL\Projects\9. RRAM\Evaluation Board\MNIST\data_256_conv16_conv32_fc10&#39;

    sys.path.append(folder_dir)

    # Load network model
    weights = torch.load(folder_dir + &#39;\\weights.pt&#39;)

    # Read the mapping and run sanity check against weights
    f = open(folder_dir + &#39;\\mapping.txt&#39;, &#39;r&#39;)
    mapping = eval(f.readline())

    # Load input data
    images = np.uint8(torch.load(folder_dir + &#39;\\images.pt&#39;))
    image_len = images.shape[1]

    # Load targets
    targets = np.uint8(torch.load(folder_dir + &#39;\\targets.pt&#39;))

    # Load predictions
    sim_preds = np.uint8(torch.load(folder_dir + &#39;\\sim_preds.pt&#39;))

    # Load the model and configure the network
    import model
    model = importlib.reload(model)

    layer = 0
    layers = []
    trainable_layer = 0
    input_length = image_len
    scale = 1

    for name, module in model.Net.named_modules(model.Net()):
        if isinstance(module, torch.ao.quantization.stubs.QuantStub) or \
           isinstance(module, torch.ao.quantization.stubs.DeQuantStub) or \
           isinstance(module, model.Net):
            continue

        layers.append({})
        #print(f&#39;Name: {name}, Module: {module}&#39;)

        # If it&#39;s a trainable layer (containing weights)
        if hasattr(module, &#39;weight&#39;):
            #print(f&#39;\tmapping layer {layer} to rram {mapping[trainable_layer][0]}&#39;)
            layers[layer][&#39;rrams&#39;] = mapping[trainable_layer]
            trainable_layer += 1
            if isinstance(module, torch.nn.modules.linear.Linear):
                layers[layer][&#39;weights&#39;] = weights[name + &#39;._packed_params._packed_params&#39;][0]
                scale = int(weights[name + &#39;.scale&#39;]/weights[name + &#39;._packed_params._packed_params&#39;][0].q_scale())
            elif isinstance(module, torch.nn.modules.conv.Conv2d):
                layers[layer][&#39;weights&#39;] = weights[name + &#39;.weight&#39;]
                scale = int(weights[name + &#39;.scale&#39;]/weights[name + &#39;.weight&#39;].q_scale())
        else:
            layers[layer][&#39;rrams&#39;] = []
            layers[layer][&#39;weights&#39;] = []

        if isinstance(module, torch.nn.modules.linear.Linear):
            layers[layer][&#39;type&#39;          ] = CM.CM_DNN_TYPE_LINEAR
            layers[layer][&#39;input_length&#39;  ] = module.in_features
            layers[layer][&#39;input_channel&#39; ] = 0
            layers[layer][&#39;kernel_length&#39; ] = module.in_features
            layers[layer][&#39;kernel_channel&#39;] = 0
            layers[layer][&#39;kernel_number&#39; ] = module.out_features
            layers[layer][&#39;stride&#39;        ] = 0
            layers[layer][&#39;output_length&#39; ] = module.out_features
            layers[layer][&#39;output_channel&#39;] = 0
            layers[layer][&#39;output_q_scale&#39;] = 1
            layers[layer][&#39;output_q_zp&#39;   ] = 0
        elif isinstance(module, torch.nn.modules.conv.Conv2d):
            layers[layer][&#39;type&#39;          ] = CM.CM_DNN_TYPE_CONV
            layers[layer][&#39;input_length&#39;  ] = input_length
            layers[layer][&#39;input_channel&#39; ] = module.in_channels
            layers[layer][&#39;kernel_length&#39; ] = module.kernel_size[0]
            layers[layer][&#39;kernel_channel&#39;] = module.in_channels
            layers[layer][&#39;kernel_number&#39; ] = module.out_channels
            layers[layer][&#39;stride&#39;        ] = module.stride[0]
            layers[layer][&#39;output_length&#39; ] = int((input_length - module.kernel_size[0])/module.stride[0] + 1)
            layers[layer][&#39;output_channel&#39;] = module.out_channels
            layers[layer][&#39;output_q_scale&#39;] = 1
            layers[layer][&#39;output_q_zp&#39;   ] = 0
        elif isinstance(module, torch.nn.modules.pooling.MaxPool2d):
            layers[layer][&#39;type&#39;          ] = CM.CM_DNN_TYPE_MAXPOOL
            layers[layer][&#39;input_length&#39;  ] = input_length
            layers[layer][&#39;input_channel&#39; ] = layers[layer-1][&#39;output_channel&#39;]
            layers[layer][&#39;kernel_length&#39; ] = module.kernel_size
            layers[layer][&#39;kernel_channel&#39;] = 1
            layers[layer][&#39;kernel_number&#39; ] = layers[layer-1][&#39;output_channel&#39;]
            layers[layer][&#39;stride&#39;        ] = module.stride
            layers[layer][&#39;output_length&#39; ] = int((input_length - module.kernel_size)/module.stride + 1)
            layers[layer][&#39;output_channel&#39;] = layers[layer-1][&#39;output_channel&#39;]
            layers[layer][&#39;output_q_scale&#39;] = 1
            layers[layer][&#39;output_q_zp&#39;   ] = 0
        elif isinstance(module, torch.nn.modules.activation.ReLU):
            layers[layer][&#39;type&#39;          ] = CM.CM_DNN_TYPE_RELU
            layers[layer][&#39;input_length&#39;  ] = input_length
            layers[layer][&#39;input_channel&#39; ] = layers[layer-1][&#39;output_channel&#39;]
            layers[layer][&#39;kernel_length&#39; ] = 0
            layers[layer][&#39;kernel_channel&#39;] = 0
            layers[layer][&#39;kernel_number&#39; ] = 0
            layers[layer][&#39;stride&#39;        ] = 0
            layers[layer][&#39;output_length&#39; ] = input_length
            layers[layer][&#39;output_channel&#39;] = layers[layer-1][&#39;output_channel&#39;]
            layers[layer][&#39;output_q_scale&#39;] = scale
            layers[layer][&#39;output_q_zp&#39;   ] = 0

        input_length = layers[layer][&#39;output_length&#39;]
        layer += 1

    layers.append({})
    layers[layer][&#39;rrams&#39;         ] = []
    layers[layer][&#39;weights&#39;       ] = []
    layers[layer][&#39;type&#39;          ] = CM.CM_DNN_TYPE_ARGMAX
    layers[layer][&#39;input_length&#39;  ] = input_length
    layers[layer][&#39;input_channel&#39; ] = layers[layer-1][&#39;output_channel&#39;]
    layers[layer][&#39;kernel_length&#39; ] = 0
    layers[layer][&#39;kernel_channel&#39;] = 0
    layers[layer][&#39;kernel_number&#39; ] = 0
    layers[layer][&#39;stride&#39;        ] = 0
    layers[layer][&#39;output_length&#39; ] = 0
    layers[layer][&#39;output_channel&#39;] = 0
    layers[layer][&#39;output_q_scale&#39;] = 1
    layers[layer][&#39;output_q_zp&#39;   ] = 0

    DNN.nn_clear(False)
    for layer_index, layer_info in enumerate(layers):
        for index_r, row in enumerate(layer_info[&#39;rrams&#39;]):
            for index_c, col in enumerate(row):
                DNN.nn_conf_rrams   (str(layer_index), str(index_r), str(index_c), str(layer_info[&#39;rrams&#39;][index_r][index_c]), False)
        DNN.nn_conf_type    (str(layer_index), str(layer_info[&#39;type&#39;]), False)
        DNN.nn_conf_input   (str(layer_index), str(layer_info[&#39;input_length&#39;]), str(layer_info[&#39;input_channel&#39;]), False)
        DNN.nn_conf_kernel  (str(layer_index), str(layer_info[&#39;kernel_length&#39;]), str(layer_info[&#39;kernel_channel&#39;]), str(layer_info[&#39;kernel_number&#39;]), str(layer_info[&#39;stride&#39;]), False)
        DNN.nn_conf_output  (str(layer_index), str(layer_info[&#39;output_length&#39;]), str(layer_info[&#39;output_channel&#39;]), False)
        DNN.nn_conf_output_q(str(layer_index), str(layer_info[&#39;output_q_scale&#39;]), str(layer_info[&#39;output_q_zp&#39;]), False)
    if verbal:
        DNN.nn_print(True)


def upload_weights(verbal):
    &#34;&#34;&#34; Upload MNIST weights on the current network

    Args:
        verbal (bool): Whether to print the uploading progress or not.
    &#34;&#34;&#34;
    def write_weights_to_rram(weights, type, rram_indices):
        if type == 0: # MLP
            np_weights = np.int8(weights.int_repr())
            (k_number, k_channel) = np_weights.shape

            for tile_ch in range(math.ceil(k_channel/256)):
                for tile_n in range(math.ceil(k_number/32)):
                    ch_offset = tile_ch*256
                    n_offset = tile_n*32
                    print(f&#39;Writing Type \&#39;{type}\&#39; weights[{tile_ch}][{tile_n}] to RRAM #{rram_indices[tile_ch][tile_n]}&#39;)
                    RRAM.switch(str(rram_indices[tile_ch][tile_n]), False)

                    if verbal:
                        print(&#39;╔════════════╦══════╦══════╦══════╗&#39;)
                        print(&#39;║ (row, col) ║ Gold ║ Read ║ Diff ║&#39;)
                        print(&#39;╟────────────╫──────╫──────╫──────╢&#39;)
                    for ch in range(min(256, k_channel-tile_ch*256)):
                        for n in range(min(32, k_number-tile_n*32)):
                            golden = int(np_weights[n_offset+n][ch_offset+ch])
                            #print(f&#39;Write {golden:&gt;5} @ ({n:&gt;2}, {ch:&gt;2}) to ({row:&gt;3}, {col:&gt;3})&#39;)
                            local_addr = ch * 256 + n
                            RRAM.write_byte_iter(str(local_addr), str(golden), True)
                            if verbal:
                                readout = int(RRAM.read_byte(str(local_addr), &#39;0&#39;, &#39;0x1&#39;, False))
                                if readout != golden:
                                    print(f&#39;║ ({ch:&gt;3}, {n:&gt;3}) ║ {golden:&gt;4} ║ {readout:&gt;4} ║ {golden-readout:&gt;4} ║&#39;)
                    if verbal:
                        print(&#39;╚════════════╩══════╩══════╩══════╝&#39;)

        elif type == 1: # CONV
            np_weights = np.int8(weights.int_repr())
            (k_number, k_channel, k_width, k_height) = np_weights.shape
            blocks_per_row = int(32 / (k_width*k_height))

            if verbal:
                print(&#39;╔════════════╦══════╦══════╦══════╗&#39;)
                print(&#39;║ (row, col) ║ Gold ║ Read ║ Diff ║&#39;)
                print(&#39;╟────────────╫──────╫──────╫──────╢&#39;)
            for n in range(k_number):
                brow = int(n / blocks_per_row)
                bcol = int(n % blocks_per_row)
                for krow in range(k_width):
                    for kcol in range(k_height):
                        for ch in range(k_channel):
                            row = brow * k_channel + ch
                            col = bcol * (k_width*k_height) + krow * k_width + kcol
                            local_addr = row * 256 + col
                            golden = int(np_weights[n][ch][krow][kcol])
                            #print(f&#39;Write {golden:&gt;5} @ ({n:&gt;2}, {ch:&gt;2}, {krow:&gt;2}, {kcol:&gt;2}) to ({row:&gt;3}, {col:&gt;3})&#39;)
                            RRAM.write_byte_iter(str(local_addr), str(golden), True)
                            if verbal:
                                readout = int(RRAM.read_byte(str(local_addr), &#39;0&#39;, &#39;0x1&#39;, False))
                                if readout != golden:
                                    print(f&#39;║ ({row:&gt;3}, {col:&gt;3}) ║ {golden:&gt;4} ║ {readout:&gt;4} ║ {golden-readout:&gt;4} ║&#39;)
            if verbal:
                    print(&#39;╚════════════╩══════╩══════╩══════╝&#39;)

    for layer_index, layer_info in enumerate(layers):
        write_weights_to_rram(layer_info[&#39;weights&#39;], layer_info[&#39;type&#39;], layer_info[&#39;rrams&#39;])


def upload_image(index, verbal):
    &#34;&#34;&#34; Upload a MNIST image on the current network

    Args:
        index (str): Index of the image
        verbal (bool): Whether to print the uploaded image or not.
    &#34;&#34;&#34;
    image = images[int(index)]

    # Upload the image
    DNN.in_conf_len(str(image_len), True)
    for i in range(image_len):
        for j in range(image_len):
            if image[i][j] != 0:
                DNN.in_fill(str(i*image_len + j), str(image[i][j]), True)

    # Print the image if required
    if verbal:
        DNN.in_print(True)


def test_inference(network, WL_start, WL_end, count, verbal):
    &#34;&#34;&#34; Test MNIST inference

    Args:
        network (str): Network type
        WL_start (str): Starting WL Scheme (1~9)
        WL_end (str): Endding WL Scheme (WL_start~9)
        count (str): Number of images that want to inference on
        verbal (bool): Whether to print the result for each image or not.
    &#34;&#34;&#34;
    verbal = eval(verbal)
    WL_start = int(WL_start)
    WL_end = int(WL_end)
    conf_network(network, True)

    for WL in range(WL_start, WL_end+1):
        print(f&#39;WL Scheme: {WL}&#39;)
        # Read the image and do th inference
        if verbal:
            print( &#39;╔═══════╦══════╦═════╦════╗&#39;)
            print(f&#39;║ Index ║ Gold ║ Sim ║ TC ║&#39;)
            print( &#39;╟───────╫──────╫─────╫────╢&#39;)
        count = int(count)
        local_targets = np.resize(targets,  count)
        local_sim_preds = np.resize(sim_preds,  count)
        tc_preds = np.empty(count, dtype=np.uint8)
        tick = time.time()
        for index in range(count):
            if not verbal:
                print(f&#39;\r\tImage {index}&#39;, end=&#39;&#39;)

            # Upload image
            upload_image(index, False)

            # Inference
            tc_preds[index] = int(DNN.forward(str(WL), False))

            # Print the result
            if verbal:
                print(f&#39;║ {index:&gt;5} ║ {local_targets[index]:&gt;4} ║ {local_sim_preds[index]:&gt;3} ║ {tc_preds[index]:&gt;2} ║&#39;)
        passed_time = time.time()-tick
        if verbal:
            print( &#39;╟───────╨──────╨─────╨────╢&#39;)
        else:
            print(&#39;&#39;)
            print( &#39;╔═════════════════════════╗&#39;)
        print(f&#39;║ Pred Acc:   {np.sum(local_sim_preds == local_targets):5d}/{count:5d} ║&#39;)
        print(f&#39;║   TC Acc:   {np.sum(tc_preds == local_targets):5d}/{count:5d} ║&#39;)
        print(f&#39;║ Duration: {passed_time:9.2f} sec ║&#39;)
        print( &#39;╚═════════════════════════╝&#39;)


class GUI:
    def __init__(self):
        &#34;&#34;&#34; MNIST GUI Demo Class

        &#34;&#34;&#34;

        # Initialize the main Panel
        self.master = Tk()
        self.master.title(&#34;MNIST GUI&#34;)

        # Change default font
        font.nametofont(&#34;TkDefaultFont&#34;).configure(family=&#34;Arial&#34;, size=12)

        # Sub panels
        frm_controls = Frame(self.master, padx=5)
        frm_canvas = Frame(self.master, padx=5)
        frm_results = Frame(self.master, padx=5)
        frm_controls.pack(side=LEFT)
        frm_canvas.pack(side=LEFT)
        frm_results.pack(side=LEFT)

        # Sub frames in Control Panel
        frm_image_index = Frame(frm_controls, borderwidth=5, relief=&#39;ridge&#39;)
        frm_network = Frame(frm_controls, borderwidth=5, relief=&#39;ridge&#39;)
        frm_wl_scheme = Frame(frm_controls, borderwidth=5, relief=&#39;ridge&#39;)
        frm_operation = Frame(frm_controls, borderwidth=5, relief=&#39;ridge&#39;)
        frm_image_index.pack(pady=5)
        frm_network.pack(pady=5)
        frm_wl_scheme.pack(pady=5)
        frm_operation.pack(pady=5)

        # Sub frames in Result Panel
        frm_golden = Frame(frm_results, borderwidth=5, relief=&#39;ridge&#39;)
        frm_duration = Frame(frm_results, borderwidth=5, relief=&#39;ridge&#39;)
        frm_prediction = Frame(frm_results, borderwidth=5, relief=&#39;ridge&#39;)
        frm_golden.pack(pady=5)
        frm_duration.pack(pady=5)
        frm_prediction.pack(pady=5)

        # In Image Index Frame
        Label(frm_image_index, text=&#39;Image Index&#39;, width=14, font=&#39;Arial 14 bold&#39;).pack()

        self.txt_image_index = Entry(frm_image_index, width=6, font=&#39;Arial 14&#39;)
        self.txt_image_index.pack(side=LEFT, padx=5)

        self.btn_random_icon = ImageTk.PhotoImage(Image.open(&#39;Applications/btn_random.png&#39;).resize((20, 20)))
        Button(frm_image_index, image=self.btn_random_icon, command=self.image_random).pack(side=RIGHT, padx=5)

        self.btn_load_icon = ImageTk.PhotoImage(Image.open(&#39;Applications/btn_load.png&#39;).resize((20, 20)))
        Button(frm_image_index, image=self.btn_load_icon, command=self.image_load).pack(side=RIGHT, padx=5)

        # In Network Type Frame
        Label(frm_network, text=&#39;Network Type&#39;, width=14, font=&#39;Arial 14 bold&#39;).pack()

        networks = (&#39;MLP&#39;, &#39;MLP2&#39;)
        self.network_var = StringVar(value=networks[0])
        OptionMenu(frm_network, self.network_var, *networks).pack(side=LEFT, padx=5)
        self.network_change(False)

        self.btn_display_network_icon = ImageTk.PhotoImage(Image.open(&#39;Applications/btn_display_network_icon.png&#39;).resize((20, 20)))
        Button(frm_network, image=self.btn_display_network_icon, command=partial(self.network_print, &#39;Current Network Architecture&#39;)).pack(side=RIGHT, padx=5)

        self.btn_config_network_icon = ImageTk.PhotoImage(Image.open(&#39;Applications/btn_load.png&#39;).resize((20, 20)))
        Button(frm_network, image=self.btn_config_network_icon, command=partial(self.network_change, True)).pack(side=RIGHT, padx=5)

        # In WL Scheme Frame
        Label(frm_wl_scheme, text=&#39;WL Scheme&#39;, width=14, font=&#39;Arial 14 bold&#39;).pack()

        self.sld_WL = Scale(frm_wl_scheme, from_=1, to=9, orient=HORIZONTAL)
        self.sld_WL.pack()

        # In Operation Frame
        Label(frm_operation, text=&#39;Operation&#39;, width=14, font=&#39;Arial 14 bold&#39;).pack()

        self.btn_clear_icon = ImageTk.PhotoImage(Image.open(&#39;Applications/btn_clear.png&#39;).resize((20, 20)))
        Button(frm_operation, image=self.btn_clear_icon, command=self.clear).pack(side=LEFT, padx=5)

        Button(frm_operation, text=&#34;Inference&#34;, command=self.image_inference, font=&#39;Arial 12&#39;).pack(side=RIGHT, padx=5)

        # In Canvas Panel
        self.old_xy = None
        self.canvas = Canvas(frm_canvas, width=400, height=400, bg=&#39;white&#39;, borderwidth=10, relief=&#39;ridge&#39;)
        self.canvas.bind(&#39;&lt;B1-Motion&gt;&#39;, self.canvas_paint)
        self.canvas.bind(&#39;&lt;ButtonRelease-1&gt;&#39;, self.canvas_reset)
        self.canvas.pack()

        # In Golden Result Frame
        Label(frm_golden, text=&#39;Golden&#39;, width=12, font=&#39;Arial 14 bold&#39;).pack()

        self.text_golden = StringVar(value=&#39;N/A&#39;)
        Label(frm_golden, textvariable=self.text_golden, font=(&#39;Arial&#39;, 48)).pack()

        # In Duration Frame
        Label(frm_duration, text=&#39;Duration (s)&#39;, width=12, font=&#39;Arial 14 bold&#39;).pack()

        self.text_duration = StringVar(value=&#39;N/A&#39;)
        Label(frm_duration, textvariable=self.text_duration, font=(&#39;Arial&#39;, 32)).pack()

        # In Prediction Frame
        Label(frm_prediction, text=&#39;Prediction&#39;, width=12, font=&#39;Arial 14 bold&#39;).pack()

        self.text_prediction = StringVar(value=&#39;N/A&#39;)
        Label(frm_prediction, textvariable=self.text_prediction, font=(&#39;Arial&#39;, 48)).pack()

        # Make it not resizable and place it at center
        self.master.resizable(False, False)
        self.window_center(self.master)
        self.master.mainloop()

    def window_center(self, window):
        &#34;&#34;&#34; Place the window at the center of the monitor

        Args:
            window (Tk or Toplevel): The target window
        &#34;&#34;&#34;
        window.update_idletasks()
        width = window.winfo_width()
        height = window.winfo_height()
        frm_width = window.winfo_rootx() - window.winfo_x()
        win_width = width + 2 * frm_width
        titlebar_height = window.winfo_rooty() - window.winfo_y()
        win_height = height + titlebar_height + frm_width
        x = window.winfo_screenwidth() // 2 - win_width // 2
        y = window.winfo_screenheight() // 2 - win_height // 2
        window.geometry(&#39;{}x{}+{}+{}&#39;.format(width, height, x, y))
        window.deiconify()


    def canvas_paint(self, new_xy):
        &#34;&#34;&#34; Callback for canvas painting

        Args:
            new_xy: new (x, y)
        &#34;&#34;&#34;
        if self.old_xy:
            self.canvas.create_line(self.old_xy.x, self.old_xy.y, new_xy.x, new_xy.y, width=40, stipple=&#39;gray50&#39;, capstyle=ROUND)
        self.old_xy = new_xy


    def canvas_reset(self, new_xy):
        &#34;&#34;&#34; Callback for canvas reset

        &#34;&#34;&#34;
        self.old_xy = None


    def canvas_capture(self):
        &#34;&#34;&#34; Capture what&#39;s on the canvas

        Returns:
            2D numpy array
        &#34;&#34;&#34;
        # Capture the image from Canvas
        ps = self.canvas.postscript(colormode=&#39;gray&#39;)
        image = Image.open(io.BytesIO(ps.encode(&#39;utf-8&#39;)))
        image = image.convert(mode=&#39;L&#39;).resize((image_len, image_len))
        image = np.uint8(image.getdata())
        image = np.floor_divide(np.invert(image), 4)
        image = np.reshape(image, (image_len, image_len))
        return image


    def clear(self):
        &#34;&#34;&#34; Clean the canvas and other related information

        &#34;&#34;&#34;
        self.canvas.delete(ALL)
        self.text_golden.set(&#39;N/A&#39;)
        self.text_prediction.set(&#39;N/A&#39;)
        self.text_duration.set(&#39;N/A&#39;)
        self.txt_image_index.delete(0, &#39;end&#39;)


    def network_change(self, verbal):
        &#34;&#34;&#34; Change the network type

        Args:
            verbal: Whether to print the updated network or not
        &#34;&#34;&#34;
        network = self.network_var.get()
        conf_network(network, False)
        if verbal:
            self.network_print(&#39;Network Architecture Updated&#39;)


    def network_print(self, win_title):
        &#34;&#34;&#34; Pop up a new window showing the updated network

        Args:
            win_title: Title of the popped up window
        &#34;&#34;&#34;
        win_network = Toplevel()
        win_network.title(win_title)
        Label(win_network, text=DNN.nn_print(False), justify= LEFT, font=&#39;Courier 14 bold&#39;).pack(fill=&#39;both&#39;, pady=5)
        Button(win_network, text=&#34;Okay&#34;, command=win_network.destroy).pack(pady=5)
        self.window_center(win_network)


    def image_load(self):
        &#34;&#34;&#34; Load image index from &#39;txt_image_index&#39;

        &#34;&#34;&#34;
        index = int(self.txt_image_index.get())

        # Paint the image onto the canvas
        tkimage = np.invert(4*images[index])
        tkimage = Image.fromarray(tkimage)
        tkimage = tkimage.resize((self.canvas.winfo_width(), self.canvas.winfo_height()))
        self.tkimage = ImageTk.PhotoImage(image=tkimage)
        self.canvas.create_image(0, 0, anchor=&#34;nw&#34;, image=self.tkimage)

        # Load golden and clear prediction/duration
        self.text_golden.set(targets[index])
        self.text_prediction.set(&#39;N/A&#39;)
        self.text_duration.set(&#39;N/A&#39;)


    def image_random(self):
        &#34;&#34;&#34; Choose a random image

        &#34;&#34;&#34;
        self.txt_image_index.delete(0, &#39;end&#39;)
        self.txt_image_index.insert(0, str(random.randint(0, 10000)))
        self.image_load()


    def image_inference(self):
        &#34;&#34;&#34; Upload the image and run inference

        &#34;&#34;&#34;
        # Clear the prediction and duration first
        self.text_prediction.set(&#39;N/A&#39;)
        self.text_duration.set(&#39;N/A&#39;)
        self.master.update()

        # Upload the image
        if self.txt_image_index.get() != &#39;&#39;:
            upload_image(str(self.txt_image_index.get()), False)
        else:
            image = self.canvas_capture()
            DNN.in_conf_len(str(image_len), True)
            for i in range(image_len):
                for j in range(image_len):
                    if image[i][j] != 0:
                        DNN.in_fill(str(i*image_len+j), str(image[i][j]), True)

        # Print the result
        tick = time.time()
        pred = DNN.forward(str(self.sld_WL.get()), False)
        passed_time = time.time()-tick
        self.text_duration.set(f&#39;{passed_time:.2f}&#39;)
        self.text_prediction.set(pred)


def decode(parameters):
    &#34;&#34;&#34; Decode the command

    Args:
        parameters (list): Command in List form.
    &#34;&#34;&#34;
    if   parameters[1] == &#39;conf_network&#39;  : conf_network(parameters[2], True         )
    elif parameters[1] == &#39;upload_weights&#39;: upload_weights(True                        )
    elif parameters[1] == &#39;upload_image&#39;  : upload_image  (parameters[2], True         )
    elif parameters[1] == &#39;test_inference&#39;: test_inference(parameters[2], parameters[3], parameters[4], parameters[5], parameters[6])
    elif parameters[1] == &#39;gui&#39;           : GUI           (                            )
    else: PT.unknown(parameters)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MNIST.conf_network"><code class="name flex">
<span>def <span class="ident">conf_network</span></span>(<span>network, verbal)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure MNIST network type</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>str</code></dt>
<dd>Network type</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to print the configured network or not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conf_network(network, verbal):
    &#34;&#34;&#34; Configure MNIST network type

    Args:
        network (str): Network type
        verbal (bool): Whether to print the configured network or not.
    &#34;&#34;&#34;

    # Some global variabls
    global folder_dir
    global weights, targets, sim_preds
    global images, image_len
    global mapping
    global layers

    # Folder directory
    if &#39;folder_dir&#39; in globals():
        sys.path.remove(folder_dir)

    if network == &#39;MLP&#39;:
        folder_dir = &#39;D:\Dropbox (GaTech)\GaTech\ICSRL\Projects\9. RRAM\Evaluation Board\MNIST\data_256_fc32_fc10&#39;
    elif network == &#39;MLP2&#39;:
        folder_dir = &#39;D:\Dropbox (GaTech)\GaTech\ICSRL\Projects\9. RRAM\Evaluation Board\MNIST\data_484_fc64_fc10&#39;
    elif network == &#39;CONV&#39;:
        folder_dir = &#39;D:\Dropbox (GaTech)\GaTech\ICSRL\Projects\9. RRAM\Evaluation Board\MNIST\data_256_conv16_conv32_fc10&#39;

    sys.path.append(folder_dir)

    # Load network model
    weights = torch.load(folder_dir + &#39;\\weights.pt&#39;)

    # Read the mapping and run sanity check against weights
    f = open(folder_dir + &#39;\\mapping.txt&#39;, &#39;r&#39;)
    mapping = eval(f.readline())

    # Load input data
    images = np.uint8(torch.load(folder_dir + &#39;\\images.pt&#39;))
    image_len = images.shape[1]

    # Load targets
    targets = np.uint8(torch.load(folder_dir + &#39;\\targets.pt&#39;))

    # Load predictions
    sim_preds = np.uint8(torch.load(folder_dir + &#39;\\sim_preds.pt&#39;))

    # Load the model and configure the network
    import model
    model = importlib.reload(model)

    layer = 0
    layers = []
    trainable_layer = 0
    input_length = image_len
    scale = 1

    for name, module in model.Net.named_modules(model.Net()):
        if isinstance(module, torch.ao.quantization.stubs.QuantStub) or \
           isinstance(module, torch.ao.quantization.stubs.DeQuantStub) or \
           isinstance(module, model.Net):
            continue

        layers.append({})
        #print(f&#39;Name: {name}, Module: {module}&#39;)

        # If it&#39;s a trainable layer (containing weights)
        if hasattr(module, &#39;weight&#39;):
            #print(f&#39;\tmapping layer {layer} to rram {mapping[trainable_layer][0]}&#39;)
            layers[layer][&#39;rrams&#39;] = mapping[trainable_layer]
            trainable_layer += 1
            if isinstance(module, torch.nn.modules.linear.Linear):
                layers[layer][&#39;weights&#39;] = weights[name + &#39;._packed_params._packed_params&#39;][0]
                scale = int(weights[name + &#39;.scale&#39;]/weights[name + &#39;._packed_params._packed_params&#39;][0].q_scale())
            elif isinstance(module, torch.nn.modules.conv.Conv2d):
                layers[layer][&#39;weights&#39;] = weights[name + &#39;.weight&#39;]
                scale = int(weights[name + &#39;.scale&#39;]/weights[name + &#39;.weight&#39;].q_scale())
        else:
            layers[layer][&#39;rrams&#39;] = []
            layers[layer][&#39;weights&#39;] = []

        if isinstance(module, torch.nn.modules.linear.Linear):
            layers[layer][&#39;type&#39;          ] = CM.CM_DNN_TYPE_LINEAR
            layers[layer][&#39;input_length&#39;  ] = module.in_features
            layers[layer][&#39;input_channel&#39; ] = 0
            layers[layer][&#39;kernel_length&#39; ] = module.in_features
            layers[layer][&#39;kernel_channel&#39;] = 0
            layers[layer][&#39;kernel_number&#39; ] = module.out_features
            layers[layer][&#39;stride&#39;        ] = 0
            layers[layer][&#39;output_length&#39; ] = module.out_features
            layers[layer][&#39;output_channel&#39;] = 0
            layers[layer][&#39;output_q_scale&#39;] = 1
            layers[layer][&#39;output_q_zp&#39;   ] = 0
        elif isinstance(module, torch.nn.modules.conv.Conv2d):
            layers[layer][&#39;type&#39;          ] = CM.CM_DNN_TYPE_CONV
            layers[layer][&#39;input_length&#39;  ] = input_length
            layers[layer][&#39;input_channel&#39; ] = module.in_channels
            layers[layer][&#39;kernel_length&#39; ] = module.kernel_size[0]
            layers[layer][&#39;kernel_channel&#39;] = module.in_channels
            layers[layer][&#39;kernel_number&#39; ] = module.out_channels
            layers[layer][&#39;stride&#39;        ] = module.stride[0]
            layers[layer][&#39;output_length&#39; ] = int((input_length - module.kernel_size[0])/module.stride[0] + 1)
            layers[layer][&#39;output_channel&#39;] = module.out_channels
            layers[layer][&#39;output_q_scale&#39;] = 1
            layers[layer][&#39;output_q_zp&#39;   ] = 0
        elif isinstance(module, torch.nn.modules.pooling.MaxPool2d):
            layers[layer][&#39;type&#39;          ] = CM.CM_DNN_TYPE_MAXPOOL
            layers[layer][&#39;input_length&#39;  ] = input_length
            layers[layer][&#39;input_channel&#39; ] = layers[layer-1][&#39;output_channel&#39;]
            layers[layer][&#39;kernel_length&#39; ] = module.kernel_size
            layers[layer][&#39;kernel_channel&#39;] = 1
            layers[layer][&#39;kernel_number&#39; ] = layers[layer-1][&#39;output_channel&#39;]
            layers[layer][&#39;stride&#39;        ] = module.stride
            layers[layer][&#39;output_length&#39; ] = int((input_length - module.kernel_size)/module.stride + 1)
            layers[layer][&#39;output_channel&#39;] = layers[layer-1][&#39;output_channel&#39;]
            layers[layer][&#39;output_q_scale&#39;] = 1
            layers[layer][&#39;output_q_zp&#39;   ] = 0
        elif isinstance(module, torch.nn.modules.activation.ReLU):
            layers[layer][&#39;type&#39;          ] = CM.CM_DNN_TYPE_RELU
            layers[layer][&#39;input_length&#39;  ] = input_length
            layers[layer][&#39;input_channel&#39; ] = layers[layer-1][&#39;output_channel&#39;]
            layers[layer][&#39;kernel_length&#39; ] = 0
            layers[layer][&#39;kernel_channel&#39;] = 0
            layers[layer][&#39;kernel_number&#39; ] = 0
            layers[layer][&#39;stride&#39;        ] = 0
            layers[layer][&#39;output_length&#39; ] = input_length
            layers[layer][&#39;output_channel&#39;] = layers[layer-1][&#39;output_channel&#39;]
            layers[layer][&#39;output_q_scale&#39;] = scale
            layers[layer][&#39;output_q_zp&#39;   ] = 0

        input_length = layers[layer][&#39;output_length&#39;]
        layer += 1

    layers.append({})
    layers[layer][&#39;rrams&#39;         ] = []
    layers[layer][&#39;weights&#39;       ] = []
    layers[layer][&#39;type&#39;          ] = CM.CM_DNN_TYPE_ARGMAX
    layers[layer][&#39;input_length&#39;  ] = input_length
    layers[layer][&#39;input_channel&#39; ] = layers[layer-1][&#39;output_channel&#39;]
    layers[layer][&#39;kernel_length&#39; ] = 0
    layers[layer][&#39;kernel_channel&#39;] = 0
    layers[layer][&#39;kernel_number&#39; ] = 0
    layers[layer][&#39;stride&#39;        ] = 0
    layers[layer][&#39;output_length&#39; ] = 0
    layers[layer][&#39;output_channel&#39;] = 0
    layers[layer][&#39;output_q_scale&#39;] = 1
    layers[layer][&#39;output_q_zp&#39;   ] = 0

    DNN.nn_clear(False)
    for layer_index, layer_info in enumerate(layers):
        for index_r, row in enumerate(layer_info[&#39;rrams&#39;]):
            for index_c, col in enumerate(row):
                DNN.nn_conf_rrams   (str(layer_index), str(index_r), str(index_c), str(layer_info[&#39;rrams&#39;][index_r][index_c]), False)
        DNN.nn_conf_type    (str(layer_index), str(layer_info[&#39;type&#39;]), False)
        DNN.nn_conf_input   (str(layer_index), str(layer_info[&#39;input_length&#39;]), str(layer_info[&#39;input_channel&#39;]), False)
        DNN.nn_conf_kernel  (str(layer_index), str(layer_info[&#39;kernel_length&#39;]), str(layer_info[&#39;kernel_channel&#39;]), str(layer_info[&#39;kernel_number&#39;]), str(layer_info[&#39;stride&#39;]), False)
        DNN.nn_conf_output  (str(layer_index), str(layer_info[&#39;output_length&#39;]), str(layer_info[&#39;output_channel&#39;]), False)
        DNN.nn_conf_output_q(str(layer_index), str(layer_info[&#39;output_q_scale&#39;]), str(layer_info[&#39;output_q_zp&#39;]), False)
    if verbal:
        DNN.nn_print(True)</code></pre>
</details>
</dd>
<dt id="MNIST.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the command</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parameters</code></strong> :&ensp;<code>list</code></dt>
<dd>Command in List form.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(parameters):
    &#34;&#34;&#34; Decode the command

    Args:
        parameters (list): Command in List form.
    &#34;&#34;&#34;
    if   parameters[1] == &#39;conf_network&#39;  : conf_network(parameters[2], True         )
    elif parameters[1] == &#39;upload_weights&#39;: upload_weights(True                        )
    elif parameters[1] == &#39;upload_image&#39;  : upload_image  (parameters[2], True         )
    elif parameters[1] == &#39;test_inference&#39;: test_inference(parameters[2], parameters[3], parameters[4], parameters[5], parameters[6])
    elif parameters[1] == &#39;gui&#39;           : GUI           (                            )
    else: PT.unknown(parameters)</code></pre>
</details>
</dd>
<dt id="MNIST.test_inference"><code class="name flex">
<span>def <span class="ident">test_inference</span></span>(<span>network, WL_start, WL_end, count, verbal)</span>
</code></dt>
<dd>
<div class="desc"><p>Test MNIST inference</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>str</code></dt>
<dd>Network type</dd>
<dt><strong><code>WL_start</code></strong> :&ensp;<code>str</code></dt>
<dd>Starting WL Scheme (1~9)</dd>
<dt><strong><code>WL_end</code></strong> :&ensp;<code>str</code></dt>
<dd>Endding WL Scheme (WL_start~9)</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>str</code></dt>
<dd>Number of images that want to inference on</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to print the result for each image or not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_inference(network, WL_start, WL_end, count, verbal):
    &#34;&#34;&#34; Test MNIST inference

    Args:
        network (str): Network type
        WL_start (str): Starting WL Scheme (1~9)
        WL_end (str): Endding WL Scheme (WL_start~9)
        count (str): Number of images that want to inference on
        verbal (bool): Whether to print the result for each image or not.
    &#34;&#34;&#34;
    verbal = eval(verbal)
    WL_start = int(WL_start)
    WL_end = int(WL_end)
    conf_network(network, True)

    for WL in range(WL_start, WL_end+1):
        print(f&#39;WL Scheme: {WL}&#39;)
        # Read the image and do th inference
        if verbal:
            print( &#39;╔═══════╦══════╦═════╦════╗&#39;)
            print(f&#39;║ Index ║ Gold ║ Sim ║ TC ║&#39;)
            print( &#39;╟───────╫──────╫─────╫────╢&#39;)
        count = int(count)
        local_targets = np.resize(targets,  count)
        local_sim_preds = np.resize(sim_preds,  count)
        tc_preds = np.empty(count, dtype=np.uint8)
        tick = time.time()
        for index in range(count):
            if not verbal:
                print(f&#39;\r\tImage {index}&#39;, end=&#39;&#39;)

            # Upload image
            upload_image(index, False)

            # Inference
            tc_preds[index] = int(DNN.forward(str(WL), False))

            # Print the result
            if verbal:
                print(f&#39;║ {index:&gt;5} ║ {local_targets[index]:&gt;4} ║ {local_sim_preds[index]:&gt;3} ║ {tc_preds[index]:&gt;2} ║&#39;)
        passed_time = time.time()-tick
        if verbal:
            print( &#39;╟───────╨──────╨─────╨────╢&#39;)
        else:
            print(&#39;&#39;)
            print( &#39;╔═════════════════════════╗&#39;)
        print(f&#39;║ Pred Acc:   {np.sum(local_sim_preds == local_targets):5d}/{count:5d} ║&#39;)
        print(f&#39;║   TC Acc:   {np.sum(tc_preds == local_targets):5d}/{count:5d} ║&#39;)
        print(f&#39;║ Duration: {passed_time:9.2f} sec ║&#39;)
        print( &#39;╚═════════════════════════╝&#39;)</code></pre>
</details>
</dd>
<dt id="MNIST.upload_image"><code class="name flex">
<span>def <span class="ident">upload_image</span></span>(<span>index, verbal)</span>
</code></dt>
<dd>
<div class="desc"><p>Upload a MNIST image on the current network</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>str</code></dt>
<dd>Index of the image</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to print the uploaded image or not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload_image(index, verbal):
    &#34;&#34;&#34; Upload a MNIST image on the current network

    Args:
        index (str): Index of the image
        verbal (bool): Whether to print the uploaded image or not.
    &#34;&#34;&#34;
    image = images[int(index)]

    # Upload the image
    DNN.in_conf_len(str(image_len), True)
    for i in range(image_len):
        for j in range(image_len):
            if image[i][j] != 0:
                DNN.in_fill(str(i*image_len + j), str(image[i][j]), True)

    # Print the image if required
    if verbal:
        DNN.in_print(True)</code></pre>
</details>
</dd>
<dt id="MNIST.upload_weights"><code class="name flex">
<span>def <span class="ident">upload_weights</span></span>(<span>verbal)</span>
</code></dt>
<dd>
<div class="desc"><p>Upload MNIST weights on the current network</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to print the uploading progress or not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload_weights(verbal):
    &#34;&#34;&#34; Upload MNIST weights on the current network

    Args:
        verbal (bool): Whether to print the uploading progress or not.
    &#34;&#34;&#34;
    def write_weights_to_rram(weights, type, rram_indices):
        if type == 0: # MLP
            np_weights = np.int8(weights.int_repr())
            (k_number, k_channel) = np_weights.shape

            for tile_ch in range(math.ceil(k_channel/256)):
                for tile_n in range(math.ceil(k_number/32)):
                    ch_offset = tile_ch*256
                    n_offset = tile_n*32
                    print(f&#39;Writing Type \&#39;{type}\&#39; weights[{tile_ch}][{tile_n}] to RRAM #{rram_indices[tile_ch][tile_n]}&#39;)
                    RRAM.switch(str(rram_indices[tile_ch][tile_n]), False)

                    if verbal:
                        print(&#39;╔════════════╦══════╦══════╦══════╗&#39;)
                        print(&#39;║ (row, col) ║ Gold ║ Read ║ Diff ║&#39;)
                        print(&#39;╟────────────╫──────╫──────╫──────╢&#39;)
                    for ch in range(min(256, k_channel-tile_ch*256)):
                        for n in range(min(32, k_number-tile_n*32)):
                            golden = int(np_weights[n_offset+n][ch_offset+ch])
                            #print(f&#39;Write {golden:&gt;5} @ ({n:&gt;2}, {ch:&gt;2}) to ({row:&gt;3}, {col:&gt;3})&#39;)
                            local_addr = ch * 256 + n
                            RRAM.write_byte_iter(str(local_addr), str(golden), True)
                            if verbal:
                                readout = int(RRAM.read_byte(str(local_addr), &#39;0&#39;, &#39;0x1&#39;, False))
                                if readout != golden:
                                    print(f&#39;║ ({ch:&gt;3}, {n:&gt;3}) ║ {golden:&gt;4} ║ {readout:&gt;4} ║ {golden-readout:&gt;4} ║&#39;)
                    if verbal:
                        print(&#39;╚════════════╩══════╩══════╩══════╝&#39;)

        elif type == 1: # CONV
            np_weights = np.int8(weights.int_repr())
            (k_number, k_channel, k_width, k_height) = np_weights.shape
            blocks_per_row = int(32 / (k_width*k_height))

            if verbal:
                print(&#39;╔════════════╦══════╦══════╦══════╗&#39;)
                print(&#39;║ (row, col) ║ Gold ║ Read ║ Diff ║&#39;)
                print(&#39;╟────────────╫──────╫──────╫──────╢&#39;)
            for n in range(k_number):
                brow = int(n / blocks_per_row)
                bcol = int(n % blocks_per_row)
                for krow in range(k_width):
                    for kcol in range(k_height):
                        for ch in range(k_channel):
                            row = brow * k_channel + ch
                            col = bcol * (k_width*k_height) + krow * k_width + kcol
                            local_addr = row * 256 + col
                            golden = int(np_weights[n][ch][krow][kcol])
                            #print(f&#39;Write {golden:&gt;5} @ ({n:&gt;2}, {ch:&gt;2}, {krow:&gt;2}, {kcol:&gt;2}) to ({row:&gt;3}, {col:&gt;3})&#39;)
                            RRAM.write_byte_iter(str(local_addr), str(golden), True)
                            if verbal:
                                readout = int(RRAM.read_byte(str(local_addr), &#39;0&#39;, &#39;0x1&#39;, False))
                                if readout != golden:
                                    print(f&#39;║ ({row:&gt;3}, {col:&gt;3}) ║ {golden:&gt;4} ║ {readout:&gt;4} ║ {golden-readout:&gt;4} ║&#39;)
            if verbal:
                    print(&#39;╚════════════╩══════╩══════╩══════╝&#39;)

    for layer_index, layer_info in enumerate(layers):
        write_weights_to_rram(layer_info[&#39;weights&#39;], layer_info[&#39;type&#39;], layer_info[&#39;rrams&#39;])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MNIST.GUI"><code class="flex name class">
<span>class <span class="ident">GUI</span></span>
</code></dt>
<dd>
<div class="desc"><p>MNIST GUI Demo Class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GUI:
    def __init__(self):
        &#34;&#34;&#34; MNIST GUI Demo Class

        &#34;&#34;&#34;

        # Initialize the main Panel
        self.master = Tk()
        self.master.title(&#34;MNIST GUI&#34;)

        # Change default font
        font.nametofont(&#34;TkDefaultFont&#34;).configure(family=&#34;Arial&#34;, size=12)

        # Sub panels
        frm_controls = Frame(self.master, padx=5)
        frm_canvas = Frame(self.master, padx=5)
        frm_results = Frame(self.master, padx=5)
        frm_controls.pack(side=LEFT)
        frm_canvas.pack(side=LEFT)
        frm_results.pack(side=LEFT)

        # Sub frames in Control Panel
        frm_image_index = Frame(frm_controls, borderwidth=5, relief=&#39;ridge&#39;)
        frm_network = Frame(frm_controls, borderwidth=5, relief=&#39;ridge&#39;)
        frm_wl_scheme = Frame(frm_controls, borderwidth=5, relief=&#39;ridge&#39;)
        frm_operation = Frame(frm_controls, borderwidth=5, relief=&#39;ridge&#39;)
        frm_image_index.pack(pady=5)
        frm_network.pack(pady=5)
        frm_wl_scheme.pack(pady=5)
        frm_operation.pack(pady=5)

        # Sub frames in Result Panel
        frm_golden = Frame(frm_results, borderwidth=5, relief=&#39;ridge&#39;)
        frm_duration = Frame(frm_results, borderwidth=5, relief=&#39;ridge&#39;)
        frm_prediction = Frame(frm_results, borderwidth=5, relief=&#39;ridge&#39;)
        frm_golden.pack(pady=5)
        frm_duration.pack(pady=5)
        frm_prediction.pack(pady=5)

        # In Image Index Frame
        Label(frm_image_index, text=&#39;Image Index&#39;, width=14, font=&#39;Arial 14 bold&#39;).pack()

        self.txt_image_index = Entry(frm_image_index, width=6, font=&#39;Arial 14&#39;)
        self.txt_image_index.pack(side=LEFT, padx=5)

        self.btn_random_icon = ImageTk.PhotoImage(Image.open(&#39;Applications/btn_random.png&#39;).resize((20, 20)))
        Button(frm_image_index, image=self.btn_random_icon, command=self.image_random).pack(side=RIGHT, padx=5)

        self.btn_load_icon = ImageTk.PhotoImage(Image.open(&#39;Applications/btn_load.png&#39;).resize((20, 20)))
        Button(frm_image_index, image=self.btn_load_icon, command=self.image_load).pack(side=RIGHT, padx=5)

        # In Network Type Frame
        Label(frm_network, text=&#39;Network Type&#39;, width=14, font=&#39;Arial 14 bold&#39;).pack()

        networks = (&#39;MLP&#39;, &#39;MLP2&#39;)
        self.network_var = StringVar(value=networks[0])
        OptionMenu(frm_network, self.network_var, *networks).pack(side=LEFT, padx=5)
        self.network_change(False)

        self.btn_display_network_icon = ImageTk.PhotoImage(Image.open(&#39;Applications/btn_display_network_icon.png&#39;).resize((20, 20)))
        Button(frm_network, image=self.btn_display_network_icon, command=partial(self.network_print, &#39;Current Network Architecture&#39;)).pack(side=RIGHT, padx=5)

        self.btn_config_network_icon = ImageTk.PhotoImage(Image.open(&#39;Applications/btn_load.png&#39;).resize((20, 20)))
        Button(frm_network, image=self.btn_config_network_icon, command=partial(self.network_change, True)).pack(side=RIGHT, padx=5)

        # In WL Scheme Frame
        Label(frm_wl_scheme, text=&#39;WL Scheme&#39;, width=14, font=&#39;Arial 14 bold&#39;).pack()

        self.sld_WL = Scale(frm_wl_scheme, from_=1, to=9, orient=HORIZONTAL)
        self.sld_WL.pack()

        # In Operation Frame
        Label(frm_operation, text=&#39;Operation&#39;, width=14, font=&#39;Arial 14 bold&#39;).pack()

        self.btn_clear_icon = ImageTk.PhotoImage(Image.open(&#39;Applications/btn_clear.png&#39;).resize((20, 20)))
        Button(frm_operation, image=self.btn_clear_icon, command=self.clear).pack(side=LEFT, padx=5)

        Button(frm_operation, text=&#34;Inference&#34;, command=self.image_inference, font=&#39;Arial 12&#39;).pack(side=RIGHT, padx=5)

        # In Canvas Panel
        self.old_xy = None
        self.canvas = Canvas(frm_canvas, width=400, height=400, bg=&#39;white&#39;, borderwidth=10, relief=&#39;ridge&#39;)
        self.canvas.bind(&#39;&lt;B1-Motion&gt;&#39;, self.canvas_paint)
        self.canvas.bind(&#39;&lt;ButtonRelease-1&gt;&#39;, self.canvas_reset)
        self.canvas.pack()

        # In Golden Result Frame
        Label(frm_golden, text=&#39;Golden&#39;, width=12, font=&#39;Arial 14 bold&#39;).pack()

        self.text_golden = StringVar(value=&#39;N/A&#39;)
        Label(frm_golden, textvariable=self.text_golden, font=(&#39;Arial&#39;, 48)).pack()

        # In Duration Frame
        Label(frm_duration, text=&#39;Duration (s)&#39;, width=12, font=&#39;Arial 14 bold&#39;).pack()

        self.text_duration = StringVar(value=&#39;N/A&#39;)
        Label(frm_duration, textvariable=self.text_duration, font=(&#39;Arial&#39;, 32)).pack()

        # In Prediction Frame
        Label(frm_prediction, text=&#39;Prediction&#39;, width=12, font=&#39;Arial 14 bold&#39;).pack()

        self.text_prediction = StringVar(value=&#39;N/A&#39;)
        Label(frm_prediction, textvariable=self.text_prediction, font=(&#39;Arial&#39;, 48)).pack()

        # Make it not resizable and place it at center
        self.master.resizable(False, False)
        self.window_center(self.master)
        self.master.mainloop()

    def window_center(self, window):
        &#34;&#34;&#34; Place the window at the center of the monitor

        Args:
            window (Tk or Toplevel): The target window
        &#34;&#34;&#34;
        window.update_idletasks()
        width = window.winfo_width()
        height = window.winfo_height()
        frm_width = window.winfo_rootx() - window.winfo_x()
        win_width = width + 2 * frm_width
        titlebar_height = window.winfo_rooty() - window.winfo_y()
        win_height = height + titlebar_height + frm_width
        x = window.winfo_screenwidth() // 2 - win_width // 2
        y = window.winfo_screenheight() // 2 - win_height // 2
        window.geometry(&#39;{}x{}+{}+{}&#39;.format(width, height, x, y))
        window.deiconify()


    def canvas_paint(self, new_xy):
        &#34;&#34;&#34; Callback for canvas painting

        Args:
            new_xy: new (x, y)
        &#34;&#34;&#34;
        if self.old_xy:
            self.canvas.create_line(self.old_xy.x, self.old_xy.y, new_xy.x, new_xy.y, width=40, stipple=&#39;gray50&#39;, capstyle=ROUND)
        self.old_xy = new_xy


    def canvas_reset(self, new_xy):
        &#34;&#34;&#34; Callback for canvas reset

        &#34;&#34;&#34;
        self.old_xy = None


    def canvas_capture(self):
        &#34;&#34;&#34; Capture what&#39;s on the canvas

        Returns:
            2D numpy array
        &#34;&#34;&#34;
        # Capture the image from Canvas
        ps = self.canvas.postscript(colormode=&#39;gray&#39;)
        image = Image.open(io.BytesIO(ps.encode(&#39;utf-8&#39;)))
        image = image.convert(mode=&#39;L&#39;).resize((image_len, image_len))
        image = np.uint8(image.getdata())
        image = np.floor_divide(np.invert(image), 4)
        image = np.reshape(image, (image_len, image_len))
        return image


    def clear(self):
        &#34;&#34;&#34; Clean the canvas and other related information

        &#34;&#34;&#34;
        self.canvas.delete(ALL)
        self.text_golden.set(&#39;N/A&#39;)
        self.text_prediction.set(&#39;N/A&#39;)
        self.text_duration.set(&#39;N/A&#39;)
        self.txt_image_index.delete(0, &#39;end&#39;)


    def network_change(self, verbal):
        &#34;&#34;&#34; Change the network type

        Args:
            verbal: Whether to print the updated network or not
        &#34;&#34;&#34;
        network = self.network_var.get()
        conf_network(network, False)
        if verbal:
            self.network_print(&#39;Network Architecture Updated&#39;)


    def network_print(self, win_title):
        &#34;&#34;&#34; Pop up a new window showing the updated network

        Args:
            win_title: Title of the popped up window
        &#34;&#34;&#34;
        win_network = Toplevel()
        win_network.title(win_title)
        Label(win_network, text=DNN.nn_print(False), justify= LEFT, font=&#39;Courier 14 bold&#39;).pack(fill=&#39;both&#39;, pady=5)
        Button(win_network, text=&#34;Okay&#34;, command=win_network.destroy).pack(pady=5)
        self.window_center(win_network)


    def image_load(self):
        &#34;&#34;&#34; Load image index from &#39;txt_image_index&#39;

        &#34;&#34;&#34;
        index = int(self.txt_image_index.get())

        # Paint the image onto the canvas
        tkimage = np.invert(4*images[index])
        tkimage = Image.fromarray(tkimage)
        tkimage = tkimage.resize((self.canvas.winfo_width(), self.canvas.winfo_height()))
        self.tkimage = ImageTk.PhotoImage(image=tkimage)
        self.canvas.create_image(0, 0, anchor=&#34;nw&#34;, image=self.tkimage)

        # Load golden and clear prediction/duration
        self.text_golden.set(targets[index])
        self.text_prediction.set(&#39;N/A&#39;)
        self.text_duration.set(&#39;N/A&#39;)


    def image_random(self):
        &#34;&#34;&#34; Choose a random image

        &#34;&#34;&#34;
        self.txt_image_index.delete(0, &#39;end&#39;)
        self.txt_image_index.insert(0, str(random.randint(0, 10000)))
        self.image_load()


    def image_inference(self):
        &#34;&#34;&#34; Upload the image and run inference

        &#34;&#34;&#34;
        # Clear the prediction and duration first
        self.text_prediction.set(&#39;N/A&#39;)
        self.text_duration.set(&#39;N/A&#39;)
        self.master.update()

        # Upload the image
        if self.txt_image_index.get() != &#39;&#39;:
            upload_image(str(self.txt_image_index.get()), False)
        else:
            image = self.canvas_capture()
            DNN.in_conf_len(str(image_len), True)
            for i in range(image_len):
                for j in range(image_len):
                    if image[i][j] != 0:
                        DNN.in_fill(str(i*image_len+j), str(image[i][j]), True)

        # Print the result
        tick = time.time()
        pred = DNN.forward(str(self.sld_WL.get()), False)
        passed_time = time.time()-tick
        self.text_duration.set(f&#39;{passed_time:.2f}&#39;)
        self.text_prediction.set(pred)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MNIST.GUI.canvas_capture"><code class="name flex">
<span>def <span class="ident">canvas_capture</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Capture what's on the canvas</p>
<h2 id="returns">Returns</h2>
<p>2D numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canvas_capture(self):
    &#34;&#34;&#34; Capture what&#39;s on the canvas

    Returns:
        2D numpy array
    &#34;&#34;&#34;
    # Capture the image from Canvas
    ps = self.canvas.postscript(colormode=&#39;gray&#39;)
    image = Image.open(io.BytesIO(ps.encode(&#39;utf-8&#39;)))
    image = image.convert(mode=&#39;L&#39;).resize((image_len, image_len))
    image = np.uint8(image.getdata())
    image = np.floor_divide(np.invert(image), 4)
    image = np.reshape(image, (image_len, image_len))
    return image</code></pre>
</details>
</dd>
<dt id="MNIST.GUI.canvas_paint"><code class="name flex">
<span>def <span class="ident">canvas_paint</span></span>(<span>self, new_xy)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for canvas painting</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_xy</code></strong></dt>
<dd>new (x, y)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canvas_paint(self, new_xy):
    &#34;&#34;&#34; Callback for canvas painting

    Args:
        new_xy: new (x, y)
    &#34;&#34;&#34;
    if self.old_xy:
        self.canvas.create_line(self.old_xy.x, self.old_xy.y, new_xy.x, new_xy.y, width=40, stipple=&#39;gray50&#39;, capstyle=ROUND)
    self.old_xy = new_xy</code></pre>
</details>
</dd>
<dt id="MNIST.GUI.canvas_reset"><code class="name flex">
<span>def <span class="ident">canvas_reset</span></span>(<span>self, new_xy)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback for canvas reset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canvas_reset(self, new_xy):
    &#34;&#34;&#34; Callback for canvas reset

    &#34;&#34;&#34;
    self.old_xy = None</code></pre>
</details>
</dd>
<dt id="MNIST.GUI.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clean the canvas and other related information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34; Clean the canvas and other related information

    &#34;&#34;&#34;
    self.canvas.delete(ALL)
    self.text_golden.set(&#39;N/A&#39;)
    self.text_prediction.set(&#39;N/A&#39;)
    self.text_duration.set(&#39;N/A&#39;)
    self.txt_image_index.delete(0, &#39;end&#39;)</code></pre>
</details>
</dd>
<dt id="MNIST.GUI.image_inference"><code class="name flex">
<span>def <span class="ident">image_inference</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upload the image and run inference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image_inference(self):
    &#34;&#34;&#34; Upload the image and run inference

    &#34;&#34;&#34;
    # Clear the prediction and duration first
    self.text_prediction.set(&#39;N/A&#39;)
    self.text_duration.set(&#39;N/A&#39;)
    self.master.update()

    # Upload the image
    if self.txt_image_index.get() != &#39;&#39;:
        upload_image(str(self.txt_image_index.get()), False)
    else:
        image = self.canvas_capture()
        DNN.in_conf_len(str(image_len), True)
        for i in range(image_len):
            for j in range(image_len):
                if image[i][j] != 0:
                    DNN.in_fill(str(i*image_len+j), str(image[i][j]), True)

    # Print the result
    tick = time.time()
    pred = DNN.forward(str(self.sld_WL.get()), False)
    passed_time = time.time()-tick
    self.text_duration.set(f&#39;{passed_time:.2f}&#39;)
    self.text_prediction.set(pred)</code></pre>
</details>
</dd>
<dt id="MNIST.GUI.image_load"><code class="name flex">
<span>def <span class="ident">image_load</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load image index from 'txt_image_index'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image_load(self):
    &#34;&#34;&#34; Load image index from &#39;txt_image_index&#39;

    &#34;&#34;&#34;
    index = int(self.txt_image_index.get())

    # Paint the image onto the canvas
    tkimage = np.invert(4*images[index])
    tkimage = Image.fromarray(tkimage)
    tkimage = tkimage.resize((self.canvas.winfo_width(), self.canvas.winfo_height()))
    self.tkimage = ImageTk.PhotoImage(image=tkimage)
    self.canvas.create_image(0, 0, anchor=&#34;nw&#34;, image=self.tkimage)

    # Load golden and clear prediction/duration
    self.text_golden.set(targets[index])
    self.text_prediction.set(&#39;N/A&#39;)
    self.text_duration.set(&#39;N/A&#39;)</code></pre>
</details>
</dd>
<dt id="MNIST.GUI.image_random"><code class="name flex">
<span>def <span class="ident">image_random</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Choose a random image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image_random(self):
    &#34;&#34;&#34; Choose a random image

    &#34;&#34;&#34;
    self.txt_image_index.delete(0, &#39;end&#39;)
    self.txt_image_index.insert(0, str(random.randint(0, 10000)))
    self.image_load()</code></pre>
</details>
</dd>
<dt id="MNIST.GUI.network_change"><code class="name flex">
<span>def <span class="ident">network_change</span></span>(<span>self, verbal)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the network type</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong></dt>
<dd>Whether to print the updated network or not</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def network_change(self, verbal):
    &#34;&#34;&#34; Change the network type

    Args:
        verbal: Whether to print the updated network or not
    &#34;&#34;&#34;
    network = self.network_var.get()
    conf_network(network, False)
    if verbal:
        self.network_print(&#39;Network Architecture Updated&#39;)</code></pre>
</details>
</dd>
<dt id="MNIST.GUI.network_print"><code class="name flex">
<span>def <span class="ident">network_print</span></span>(<span>self, win_title)</span>
</code></dt>
<dd>
<div class="desc"><p>Pop up a new window showing the updated network</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>win_title</code></strong></dt>
<dd>Title of the popped up window</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def network_print(self, win_title):
    &#34;&#34;&#34; Pop up a new window showing the updated network

    Args:
        win_title: Title of the popped up window
    &#34;&#34;&#34;
    win_network = Toplevel()
    win_network.title(win_title)
    Label(win_network, text=DNN.nn_print(False), justify= LEFT, font=&#39;Courier 14 bold&#39;).pack(fill=&#39;both&#39;, pady=5)
    Button(win_network, text=&#34;Okay&#34;, command=win_network.destroy).pack(pady=5)
    self.window_center(win_network)</code></pre>
</details>
</dd>
<dt id="MNIST.GUI.window_center"><code class="name flex">
<span>def <span class="ident">window_center</span></span>(<span>self, window)</span>
</code></dt>
<dd>
<div class="desc"><p>Place the window at the center of the monitor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>window</code></strong> :&ensp;<code>Tk</code> or <code>Toplevel</code></dt>
<dd>The target window</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def window_center(self, window):
    &#34;&#34;&#34; Place the window at the center of the monitor

    Args:
        window (Tk or Toplevel): The target window
    &#34;&#34;&#34;
    window.update_idletasks()
    width = window.winfo_width()
    height = window.winfo_height()
    frm_width = window.winfo_rootx() - window.winfo_x()
    win_width = width + 2 * frm_width
    titlebar_height = window.winfo_rooty() - window.winfo_y()
    win_height = height + titlebar_height + frm_width
    x = window.winfo_screenwidth() // 2 - win_width // 2
    y = window.winfo_screenheight() // 2 - win_height // 2
    window.geometry(&#39;{}x{}+{}+{}&#39;.format(width, height, x, y))
    window.deiconify()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MNIST.conf_network" href="#MNIST.conf_network">conf_network</a></code></li>
<li><code><a title="MNIST.decode" href="#MNIST.decode">decode</a></code></li>
<li><code><a title="MNIST.test_inference" href="#MNIST.test_inference">test_inference</a></code></li>
<li><code><a title="MNIST.upload_image" href="#MNIST.upload_image">upload_image</a></code></li>
<li><code><a title="MNIST.upload_weights" href="#MNIST.upload_weights">upload_weights</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MNIST.GUI" href="#MNIST.GUI">GUI</a></code></h4>
<ul class="two-column">
<li><code><a title="MNIST.GUI.canvas_capture" href="#MNIST.GUI.canvas_capture">canvas_capture</a></code></li>
<li><code><a title="MNIST.GUI.canvas_paint" href="#MNIST.GUI.canvas_paint">canvas_paint</a></code></li>
<li><code><a title="MNIST.GUI.canvas_reset" href="#MNIST.GUI.canvas_reset">canvas_reset</a></code></li>
<li><code><a title="MNIST.GUI.clear" href="#MNIST.GUI.clear">clear</a></code></li>
<li><code><a title="MNIST.GUI.image_inference" href="#MNIST.GUI.image_inference">image_inference</a></code></li>
<li><code><a title="MNIST.GUI.image_load" href="#MNIST.GUI.image_load">image_load</a></code></li>
<li><code><a title="MNIST.GUI.image_random" href="#MNIST.GUI.image_random">image_random</a></code></li>
<li><code><a title="MNIST.GUI.network_change" href="#MNIST.GUI.network_change">network_change</a></code></li>
<li><code><a title="MNIST.GUI.network_print" href="#MNIST.GUI.network_print">network_print</a></code></li>
<li><code><a title="MNIST.GUI.window_center" href="#MNIST.GUI.window_center">window_center</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>